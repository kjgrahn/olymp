#!/usr/bin/python
# -*- coding: iso-8859-1 -*-
#
# Copyright (c) 2002--2012, 2014 Jörgen Grahn
# All rights reserved.
#
"""enumerate and/or rename digital camera photos
"""
import os
import re

def _cvs_says(dollarname='$Name:  $'):
    m = re.match(r'\$'r'Name:\s+(.+?)-(\d+(-\d+)*)\D', dollarname)
    if not m: return ('olymp', 'unknown')
    return m.group(1), m.group(2).replace('-', '.')

_edatere = re.compile(r'(20\d{2}:\d{2}:\d{2})\s(\d{2}:\d{2}):\d{2}')

def exifdate(f):
    """Find a date on the form '2005:10:23 20:04:17' in the EXIF
    information of file 'f', and return it as a tuple on the form
    ('2005-10-23', '20:04').

    XXX Until I can find or write /good/ EXIF parsing code, this is
    done the boneheaded way -- regexing straight into the first blocks
    of the file.
    """
    f = open(f, 'rb')
    s = f.read(4*1024)
    f.close()
    m = _edatere.search(s)
    if not m:
        raise ValueError('no EXIF date in file')
    date, time = m.groups()
    return (date.replace(':', '-'),
            time)

def olymp(files, output, errput, rename=0):
    """Investigate 'files', a sequence of file names, and print a
    better name, and date/time stamp, to file-like object 'output'.

    If 'rename' is set, also try to rename them accordingly.
    Whines to 'errput' if something goes wrong, and also returns false.
    """
    olympre = re.compile(r'p[0-9abc]\d{2}(\d{4})\.jpg$', re.IGNORECASE)
    otherre = re.compile(r'(?:.+?_|DSC|DSCN|IMAG)(\d+)(\..*)?$', re.IGNORECASE)
    for f in files:
        dir, fname = os.path.split(f)
        m = olympre.match(fname)
        if not m:
            m = otherre.match(fname)
        if not m:
            print >>errput, "skipping", f, '- no serial number in the file name'
            continue
        serial = int(m.group(1))
        try:
            date, time = exifdate(f)
            newname = '%s_%04d.jpg' % (date, serial)
            print >>output, ''
            print >>output, newname
            print >>output, '%s %s' % (date, time)
            if rename and not fname==newname:
                oldpath = f
                newpath = os.path.join(dir, newname)
                if os.path.exists(newpath):
                    print >>errput, 'not renaming', f, '-', newpath, 'exists'
                    continue
                os.rename(oldpath, newpath)
        except (ValueError, IOError), s:
            print >>errput, '%s: %s' % (f, s)
    return 1

if __name__ == "__main__":
    import getopt
    import sys

    prog = os.path.split(sys.argv[0])[1]
    usage = 'usage: %s [-e] file ...' % prog
    try:
        rename = 0
        opts, files = getopt.getopt(sys.argv[1:], 'e', ['version'])
        for opt, val in opts:
            if opt=='-e':
                rename = 1
            elif opt=='--version':
                print '%s, version %s' % _cvs_says()
                print 'Copyright (c) 2002--2012, 2014 Jörgen Grahn'
                print 'All rights reserved.'
                sys.exit(0)
        if not len(files):
            raise ValueError, 'arguments missing'
    except (ValueError, getopt.GetoptError), s:
        print >>sys.stderr, 'error:', s
        print >>sys.stderr, usage
        sys.exit(1)

    rc = olymp(files, sys.stdout, sys.stderr, rename)
    if not rc:
        sys.exit(1)
    sys.exit(0)
